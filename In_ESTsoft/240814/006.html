<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map 과 Set</title>
</head>
<body>
    <script>
        // Set
        // 중복을 허락하지 않는 자료형
        // 중복하지 않는 데이터를 저장할 때 사용
        // 중복을 제거하는 용도로도 사용

        let s = new Set();

        s.add('apple');
        s.add('banana');
        s.add('banana');
        s.add('banana');
        s.add('orange');
        
        console.log(s); // Set(3) {"apple", "banana", "orange"}

        ///////////////////////////

        let ss = new Set('abcdeeeeeeeee');
        
        console.log(ss);
        console.log(ss.size);

        // 배열에서도 사용가넝!
        let sss = new Set([10, 20, 30, 10, 20, 30, 30]);
        
        console.log(sss);
        console.log(sss.size);
        console.log(sss.has(10));

        console.log(sss.delete(10)); // true
        console.log(sss.has(10)); // false
        
        ///////////////////////////

        let setA = new Set(['apple', 'banana', 'orange']);
        let setB = new Set(['banana', 'kiwi', 'orange']);
        
        // 교집합
        let intersection = new Set([...setA].filter(x => setB.has(x)));
        console.log(intersection); // Set(2) {"banana", "orange"}
        
        // 합집합
        let union = new Set([...setA, ...setB]);
        console.log(union); // Set(4) {"apple", "banana", "orange", "kiwi"}
        
        // 차집합
        let difference = new Set([...setA].filter(x => !setB.has(x)));
        console.log(difference); // Set(1) {"apple"}

        // array에 filter와 reduce
        let arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
        arr.filter(x => x % 2 == 1); // 저 조건식이 true인 것만 출력

        // reduce는 배열의 각 요소를 연산합니다.
        let arr2 = [1, 2, 3, 4, 5];
        arr2.reduce((a, c) => a + c, 0); // a는 누적값(accumulator), c는 현재값 (current value)
        // 0이 없으면 비어있는 배열일때 에러가 남.
    </script>
</body>
</html>